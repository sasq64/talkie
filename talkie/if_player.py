import queue
import re
import subprocess
import threading
import time
from dataclasses import dataclass
from importlib import resources
from logging import getLogger
from pathlib import Path
from typing import Final

from .text_utils import parse_adventure_description, trim_lines, unwrap_text

logger = getLogger(__name__)


@dataclass
class Line:
    x0: int
    y0: int
    x1: int
    y1: int
    col0: int
    col1: int


@dataclass
class Fill:
    x: int
    y: int
    col0: int
    col1: int


@dataclass
class SetColor:
    color: int
    index: int


@dataclass
class Clear:
    pass


@dataclass
class ShowBitmap:
    bitmap: int


@dataclass
class ImageInfo:
    no: int
    width: int
    height: int
    numcolors: int


@dataclass
class Palette:
    no: int
    colors: list[int]


@dataclass
class Pixels:
    no: int
    pixel_indices: list[int]  # List of palette indices


Command = Fill | Line | Clear | SetColor | ShowBitmap | ImageInfo | Palette | Pixels

# Registry mapping command names to (class, argument types)
COMMANDS: dict[str, tuple[type[Command], list[type]]] = {
    "line": (Line, [int, int, int, int, int, int]),
    "fill": (Fill, [int, int, int, int]),
    "clear": (Clear, []),
    "setcolor": (SetColor, [int, int]),
}


def parse_command(s: str) -> Command | None:
    parts = s.split()
    cmd, args = parts[0], parts[1:]

    # Handle special bitmap commands
    if cmd == "img" and len(args) == 4:
        return ImageInfo(int(args[0]), int(args[1]), int(args[2]), int(args[3]))
    elif cmd == "pal" and len(args) >= 1:
        no = int(args[0])
        colors: list[int] = []
        for color_str in args[1:]:
            colors.append(int(color_str, 0))
        return Palette(no, colors)
    elif cmd == "pixels" and len(args) >= 1:
        no = int(args[0])
        pixel_indices: list[int] = []
        for pixel_str in args[1:]:
            pixel_indices.append(int(pixel_str, 0))
        return Pixels(no, pixel_indices)

    if cmd not in COMMANDS:
        return None

    cls, types = COMMANDS[cmd]

    if len(args) != len(types):
        raise ValueError(f"Wrong number of arguments for {cmd}: {args}")

    # Convert arguments to expected types
    converted = [t(a) for t, a in zip(types, args, strict=False)]
    return cls(*converted)


class IFPlayer:
    def __init__(self, file_name: Path):
        zcode = re.compile(r"\.z(ode|[123456789])$")
        l9 = re.compile(r"\.l9$")
        data = resources.files("talkie.data")

        self.commands: list[Command] = []

        if zcode.search(file_name.name):
            args = ["dfrotz", "-m", "-w", "1000", file_name.as_posix()]
        elif l9.search(file_name.name):
            args = [str(data / "l9"), file_name.as_posix()]
        else:
            raise RuntimeError("Unknown format")
        print(args)

        self.proc: Final = subprocess.Popen(
            args,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )
        self.output_queue: queue.Queue[bytes] = queue.Queue()
        self.transcript: list[tuple[str, str]] = []
        self.text_output: str = ""
        self.last_result: float = 0

        def read_output():
            if self.proc.stdout:
                while True:
                    data: bytes = self.proc.stdout.read1(16384)  # type: ignore
                    if not data:
                        break
                    self.output_queue.put(data)

        self.output_thread: Final = threading.Thread(target=read_output, daemon=True)
        self.output_thread.start()

        # Register this instance for cleanup
        # global _active_players
        # _active_players.append(self)
        self._closed : bool = False

    def get_commands(self) -> list[Command]:
        """Get any graphic commands generated by the running interpreter."""

        result = self.commands
        self.commands = []
        return result

    def read(self) -> dict[str, str] | None:
        """
        Read stdout from running interpreter. Returns a dict containing
        both the raw text and context aware parsing (like stripping the
            status bar from frotz etc).
        """
        try:
            raw_text = self.output_queue.get_nowait()
            result = raw_text.decode()
            self.text_output += result
            self.last_result = time.time()
        except queue.Empty:
            pass
        return self._handle_output()

    def _handle_output(self):
        if not self.text_output or time.time() - self.last_result < 0.25:
            return None
        meta = re.compile(r"#\[(.*?)\]\n?")
        text = trim_lines(self.text_output)
        for line in text.splitlines():
            for m in meta.findall(line):
                cmd = parse_command(m)
                if cmd is not None:
                    self.commands.append(cmd)
        text = meta.sub("", text)

        text = unwrap_text(text)
        ps = text.split("\n\n")
        if len(ps) > 2:
            first = ps[0].strip()
            for px in ps[1:]:
                if px and px.splitlines()[0].strip() == first:
                    logger.debug(f"Dropping first line '{first}'")
                    _ = ps.pop(0)
                    break
            text = "\n\n".join(ps)
        fields = parse_adventure_description(text)
        logger.debug(f"Parsed: '{text}' into:\n{fields}")
        self.transcript.append((":", fields["text"]))
        fields["full_text"] = self.text_output
        self.text_output = ""
        return fields

    def write(self, text: str):
        """Write text line to stdin of running interpreter."""

        if self.proc.stdin is not None:
            logger.info(f"IN: '{text}'")
            _ = self.proc.stdin.write(text.encode())
            self.transcript.append((">", text))
            self.proc.stdin.flush()

    def get_transcript(self) -> str:
        """Get the transcript of the game so far."""

        lines: list[str] = []
        for c, line in self.transcript:
            if c == ">":
                lines.append("\n>" + line)
            else:
                lines.append(line)
        return "\n".join(lines)

    def _cleanup(self):
        """Internal cleanup method to terminate subprocess and thread."""
        if self._closed:
            return

        self._closed = True
        # Terminate the subprocess
        if hasattr(self, "proc") and self.proc:
            try:
                # Close stdin to signal the process to exit gracefully
                if self.proc.stdin:
                    self.proc.stdin.close()

                # Wait briefly for graceful shutdown
                try:
                    _ = self.proc.wait(timeout=1.0)
                except subprocess.TimeoutExpired:
                    # Force kill if it doesn't exit gracefully
                    logger.warning("Subprocess didn't exit gracefully, terminating...")
                    self.proc.terminate()
                    try:
                        _ = self.proc.wait(timeout=2.0)
                    except subprocess.TimeoutExpired:
                        logger.warning("Subprocess didn't respond to TERM, killing...")
                        self.proc.kill()
                        _ = self.proc.wait()

                logger.info(
                    f"IFPlayer subprocess terminated with return code: {self.proc.returncode}"
                )
            except Exception as e:
                logger.error(f"Error terminating subprocess: {e}")

    def close(self):
        """Explicitly close the IFPlayer and cleanup resources."""
        self._cleanup()

    def __del__(self):
        """Ensure cleanup during garbage collection."""
        try:
            self._cleanup()
        except Exception:
            # Ignore errors during garbage collection
            pass

    def __enter__(self):
        """Context manager entry."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit with cleanup."""
        self.close()
        return False
